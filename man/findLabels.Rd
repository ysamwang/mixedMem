% Generated by roxygen2 (4.0.2): do not edit by hand
\name{findLabels}
\alias{findLabels}
\title{Mixed Membership Post-Processing}
\usage{
findLabels(model, training, exhaustive = TRUE)
}
\arguments{
\item{model}{the fitted \code{mixedMemModel} object}

\item{training}{the ground truth theta}

\item{exhaustive}{a boolean for whether an exhaustive search should be performed. If false, a greedy algorithim is used instead}
}
\value{
perm optimal permutation with respect to squared error loss

loss the sum of squared error loss of the optimal permutation weighted by relative frequency
}
\description{
Finds the permutation of labels that minimizes
the weighted squared error loss between the fitted theta and a ground truth theta.
}
\details{
Mixed Membership models are invariant to permutations of the sub-population labels and the ordering of the labels in a fitted model
is dependent on the initialization points of the variational EM algorithim. The \code{findLabels} function selects an
optimal permutation of the labels to match a given ground truth.
The loss function is the weighted sum of squared differences where the weights are determined by the relative frequency of each group.

\eqn{Loss = \sum_j \sum_k \alpha_k/\alpha_0 [\sum_v (\hat\theta_{k,v} - \theta_{k,v})^2]}
where \eqn{\alpha_0 = \sum_k \alpha_k}

If K, number of sub-populations, is small, the method can search through all K! permutations and
select the permutation which minimizes the loss. If K is large, a greedy algorithim can be used instead. This
algorithim selects the best match for each fitted sub-population starting with the group with the largest fitted
relative frequency.
}
\examples{
\dontshow{
set.seed(123)
Total <- 50 # 50 Individuals
J <- 3 # 2 different variables
dist <- c("multinomial", "bernoulli", "rank") # distributions of each variable
Rj <- c(100, 5, 1) # 100 repeated measures of the multinomial, 5 repeated measures of the bernoulli, 1 repeated measure of the rank
Nijr <- array(1, dim = c(Total, J, max(Rj))) #Nijr will always be 1 for multinomials and bernoulli's
K <- 4 # 4 sub-populations
alpha <- rep(.5, K) #hyperparameter for dirichlet distribution
Vj <- c(10, 1, 4) # Number of choices for each variable. Note the Bernoulli must have 1 choice

theta <- array(0, dim = c(J, K, max(Vj)))
# Parameters governing multinomial
theta[1,,] <- gtools::rdirichlet(K, rep(.3, Vj[1]))
#parameters governing bernoulli
theta[2,,] <- cbind(rbeta(K, 1,1), matrix(0, nrow = K, ncol = Vj[1]-1))
theta[3,,] <- cbind(gtools::rdirichlet(K, rep(.3, Vj[3])), matrix(0, nrow = K, ncol = Vj[1]-Vj[3]))

# generate group memberships
lambda <- gtools::rdirichlet(Total, rep(.2,K))

# Candidates selected for each observation. For Multinomial and Bernoulli, this is always 1
Nijr = array(0, dim = c(Total, J, max(Rj)))
Nijr[,1,c(1:Rj[1])] = 1
Nijr[,2,c(1:Rj[2])] = 1
Nijr[,3,c(1:Rj[3])] = sample.int(Vj[3], size = Total, replace = TRUE)

## Generate Observations
obs = array(0, dim = c(Total, J, max(Rj), max(Nijr)))
for(i in 1:Total)
{
  for(j in 1:J)
  {
    for(r in 1:Rj[j])
    {
      sub.pop <- sample.int(K, size = 1, prob = lambda[i,]) # sub-population which governs the multinomial
      if(dist[j] =="multinomial") {
        obs[i,j,r,1] <- sample.int(Vj[j], size = 1, prob = theta[j,sub.pop,c(1:Vj[j])])-1 # must be in 0:(Vj[j]-1)
      }
      if(dist[j] == "rank") {
        obs[i,j,r,c(1:Nijr[i,j,r])] <- sample.int(Vj[j], size = Nijr[i,j,r], replace = FALSE, prob = theta[j,sub.pop,c(1:Vj[j])])-1  # must be in 0:(Vj[j]-1)
      }
      if(dist[j] == "bernoulli"){
        obs[i,j,r,1] <- rbinom(n = 1, size = 1, prob = theta[j,sub.pop,1])
      }
    }
  }
}
}

# See mixedMemModel documentation for how to generate data and instantiate a mixedMemModel object
# After the data as been generated, we initialize theta to a permutation of the true labeling
set.seed(123)
perm = sample.int(K, size = K, replace = FALSE)
theta1 = theta[,perm,]
test_model <- mixedMemModel(Total = Total, J = J,Rj = Rj, Nijr= Nijr, K = K, Vj = Vj,dist = dist,
 obs = obs, alpha = alpha, theta = theta1)
out <- mmVarFit(test_model)
opt.perm <- findLabels(out, theta)
opt.perm

# produce mixedMemModel object with labels permuted to match ground truth
out = permuteLabels(out, opt.perm$perm)
}
\seealso{
permuteLabels
}

